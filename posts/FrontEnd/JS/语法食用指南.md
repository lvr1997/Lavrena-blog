### this

它指向什么完全取决于函数在哪里调用，在 Es5 中 this 永远指向调用它的那个对象，而在 Es6 的箭头函数中没有this 绑定，this 指向箭头函数定义时所在的作用域中的 this 判断this

全局作用域、自执行函数、定时器传进的非箭头函数的 this 都指向 window 严格模式(use strict)下的 this 指向 undefined 构造函数中的this指向当前的实例 事件绑定函数中的this指向当前被绑定的元素 箭头函数中this指向定义箭头函数的上级作用域中的this 改变this指向

使用 call, apply, bind，call 和 apply 改变 this 指向时，函数会立即执行，bind 不会 保存成变量(let self = this) 使用箭头函数 使用 new 实例化一个对象 严格模式下直接调用函数 this 指向 undefined 箭头函数硬绑定的 this 无法被修改，比如 fn.call(window)，再把 fn 赋值给对象的属性后，调用对象的方法 this 依然是 window

### 类型判断

- typeof
    
    - 基础类型
        
        typeof 1 === “number” // true typeof “a” === “string” // true typeof true === “boolean” // true typeof undefined === “undefined” // true typeof Symbol() === “symbol” // true
        
    - 引用类型
        
        引用类型 typeof null === “object” // true typeof {} === “object” // true typeof [] === “object” // true typeof function () {} === “function” // true
        
- toString
    
    toString
    
    let toString = Object.prototype.toString
    
    console.log(toString.call(1)) // [object Number] console.log(toString.call(‘1’)) // [object String] console.log(toString.call(true)) // [object Boolean] console.log(toString.call(undefined)) // [object Undefined] console.log(toString.call(null)) // [object Null] console.log(toString.call({})) // [object Object] console.log(toString.call([])) // [object Array] console.log(toString.call(function(){})) // [object Function] console.log(toString.call(new Date)) // [object Date]
    
- 其他判断
    
    其他判断
    
    // constructor 判断是否是该类型直接继承者 let A = function(){} let B = new A() A.constructor === Object // false A.constructor === Function // true B.constructor === Function // false B.constructor === A // true
    
    // 判断数组 console.log(Array.isArray([])) // true // 判断数字 function isNumber(num) { let reg = /[1](about:blank#fn1)+.?[0-9]*$/ if (reg.test(num)) { return true } return false }
    
    //封装获取数据类型 function getType(obj){ let type = typeof obj if(type !== ‘object’){ return type } return Object.prototype.toString.call(obj) }
    
    // 含隐式类型转换 继续往下看
    
    // 判断数字 function isNumber(num) { return num === +num } // 判断字符串 function isString(str) { return str === str+“” } // 判断布尔值 function isBoolean(bool) { return bool === !!bool }
    

### 类型转换

- 显示转换
    
    - Number()
        
        1. Number()
        
        console.log(Number(1)) // 1 console.log(Number(“1”)) // 1 console.log(Number(“1a”)) // NaN console.log(Number(true)) // 1 console.log(Number(undefined)) // NaN console.log(Number(null)) // 0 console.log(Number({a:1})) // NaN 原因往下看 复制代码 原始类型转换
        
        数字：转换后还是原来的值 字符串：如果能被解析成数字，就得到数字，否则就是 NaN，空字符串为0 布尔值：true 转为1，false 转为0 undefined: 转为 NaN null：转为0 引用类型转换
        
        let a = {a:1} console.log(Number(a)) // NaN // 原理 a.valueOf() // {a:1} a.toString() // “[object Object]” Number(“[object Object]”) // NaN 复制代码 先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值(数值、字符串和布尔值)，则直接对该值使用 Number 方法，不再继续 如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再继续 如果 toString 方法返回的还是复合类型的值，则报错
        
    - String()
        
        1. String()
        
        console.log(String(1)) // “1” console.log(String(“1”)) // “1” console.log(String(true)) // “true” console.log(String(undefined)) // “undefined” console.log(String(null)) // “null” console.log(String({b:1})) // “[object Object]” 原因往下看 复制代码 原始类型转换
        
        数字：转换成相应字符串 字符串：转换后还是原来的值 布尔值：true 转为”true”，false 转为”false” undefined: 转为”undefined” null：转为”null” 引用类型转换
        
        let b = {b:1} console.log(String(b)) // “[object Object]” // 原理 b.toString() // “[object Object]” // b.valueOf() 由于返回的不是复合类型所以没有调valueOf() String(“[object Object]”) // “[object Object]” 复制代码 先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再继续 如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再继续 如果 valueOf 方法返回的是复合类型的值，则报错
        
    - Boolean()
        
        1. Boolean()
        
        console.log(Boolean(0)) // flase console.log(Boolean(-0)) // flase console.log(Boolean(““)) // flase console.log(Boolean(null)) // flase console.log(Boolean(undefined)) // flase console.log(Boolean(NaN)) // flase 复制代码 原始类型转换
        
        0 -0 “” null undefined NaN 以上统一转为false，其他一律为true
        
- 隐式转换
    
    隐式转换
    
    // 四则运算 如把String隐式转换成Number console.log(+‘1’ === 1) // true
    
    // 判断语句 如把String隐式转为Boolean if (‘1’) console.log(true) // true
    
    // Native调用 如把Object隐式转为String alert({a:1}) // “[object Object]” console.log(([#](about:blank#)]+[])[+!![]]+([]+{})[!+[]+!![]]) // “nb”
    
    // JSON方法 如把String隐式转为Object console.log(JSON.parse(“{a:1}”)) // {a:1} 复制代码 几道隐式转换题
    
    console.log( true+true ) // 2 解：true相加是用四则运算隐式转换Number 就是1+1 console.log( 1+{a:1} ) // “1[object Object]” 解：上面说了Native调用{a:1}为”[object Object]” 数字1+字符串直接拼接 console.log( []+[] ) // “” 解：String([]) =》 [].toString() = “” =》 ““+”” =》 “” console.log( []+{} ) // “[object Object]” 解：“” + String({}) =》 “” + {}.toString() = “” + “[object Object]” =》 “[object Object]” console.log( {}+{} ) // “[object Object](about:blank#)” 和上面同理 复制代码 运算符优先级，图来自MDN
    

### 深浅拷贝

- 浅拷贝 第一层是引用类型就拷贝指针，不是就拷贝值。拷贝栈不拷贝堆
    
    // 1. 展开运算符 … let obj1 = { a:1, b:{ c:3 } } let obj2 = { …obj1 } obj1.a = ‘a’ obj1.b.c = ‘c’ console.log(obj1) // { a:‘a’, b:{ c:‘c’ } } console.log(obj2) // { a:1, b:{ c:‘c’ } }
    
    // 2. Object.assign() 把obj2合并到obj1 Object.assign(obj1, obj2)
    
    // 3. 手写 function clone(target){ let obj = {} for(let key in target){ obj[key] = target[key] } return obj }
    
    // 4. 数组浅拷贝 用Array方法 concat()和slice() let arr1 = [ 1,2,{ c:3 } ] let arr2 = arr1.concat() let arr3 = arr1.slice()
    
- 深拷贝
    

复制代码 优化版

用WeakMap替代Map，上面说了WeakMap是弱引用，Map是强引用 选择性能更好的循环方式 for in 每次迭代操作会同时搜索实例和原型属性，会产生更多的开销，所以用 while

// 用while来实现一个通用的forEach遍历 function forEach(array, iteratee) { let index = -1; const length = array.length; while (++index < length) { iteratee(array[index], index); } return array; } // WeakMap 对象是键/值对集合，键必须是对象，而且是弱引用的，值可以是任意的 function clone(target, map = new WeakMap()){ // 引用类型才继续深拷贝 if (target instanceof Object) { const isArray = Array.isArray(target) // 克隆对象和数组类型 let cloneTarget = isArray ? [] : {}

`Plain Text   // 防止循环引用   if (map.get(target)) {       // 有拷贝记录就直接返回       return map.get(target)   }   // 没有就存储拷贝记录   map.set(target,cloneTarget)       // 是对象就拿出同级的键集合 返回是数组格式   const keys = isArray ? undefined : Object.keys(target)   // value是对象的key或者数组的值 key是下标   forEach(keys || target, (value, key) => {       if (keys) {           // 是对象就把下标换成value           key = value       }       // 递归       cloneTarget[key] = clone(target[key], map)   })   return cloneTarget } else {   return target }`

}

## ES6语法加油站

- Promise

### 事件循环

这几个主要都是考笔试题，所以只要会手写 Promise 的几个方法，知道事件循环，就肯定没问题了 Promise 构造函数是同步执行的，then 方法是异步执行的(微任务) async/await 本质上就是 Promise，只不过她可以在不阻塞主线程的情况下，使用同步代码实现异步访问。 缺点是 await 会阻塞代码，要是她之后的异步代码不依赖她的结果，也还是要等她完成，失去了并发性，这时候就建议用 Promise.all 看例子，顺便复习事件循环

async function fun() { console.log(1) let a = await 2 console.log(a) console.log(3) } console.log(4) fun() console.log(5) 复制代码 输出结果：4 1 5 2 3 结合 async / await 的特点，我们来把这个题用 ES6 翻译一下

function fun(){ return new Promise(() => { console.log(1) Promise.resolve(2).then( a => { console.log(a) console.log(3) }) }) } console.log(4) fun() console.log(5) 复制代码 想研究一下 Promise 的可以看这篇文章 Promise 你真的用明白了么 最后问一个问题： async/await 经过编译后和 generator 有啥联系？

### Ajax

### Promise

这几个主要都是考笔试题，所以只要会手写 Promise 的几个方法，知道事件循环，就肯定没问题了 Promise 构造函数是同步执行的，then 方法是异步执行的(微任务) async/await 本质上就是 Promise，只不过她可以在不阻塞主线程的情况下，使用同步代码实现异步访问。 缺点是 await 会阻塞代码，要是她之后的异步代码不依赖她的结果，也还是要等她完成，失去了并发性，这时候就建议用 Promise.all 看例子，顺便复习事件循环

async function fun() { console.log(1) let a = await 2 console.log(a) console.log(3) } console.log(4) fun() console.log(5) 复制代码 输出结果：4 1 5 2 3 结合 async / await 的特点，我们来把这个题用 ES6 翻译一下

function fun(){ return new Promise(() => { console.log(1) Promise.resolve(2).then( a => { console.log(a) console.log(3) }) }) } console.log(4) fun() console.log(5) 复制代码 想研究一下 Promise 的可以看这篇文章 Promise 你真的用明白了么 最后问一个问题： async/await 经过编译后和 generator 有啥联系？

### Generator与async/await

### 垃圾回收

- 标记清除算法
    
    策略 标记清除（Mark-Sweep），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异 就像它的名字一样，此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁 你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略 引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树 等 整个标记清除算法大致过程就像下面这样
    
    垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0 然后从各个根对象开始遍历，把不是垃圾的节点改成1 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收 优点 标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单 缺点 标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
    
    假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配（如下图）
    
    那如何找到合适的块呢？我们可以采取下面三种分配策略
    
    First-fit，找到大于等于 size 的块立即返回 Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块 Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回 这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择 综上所述，标记清除算法或者说策略就有两个很明显的缺点
    
    内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢 PS：标记清除算法的缺点补充 归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了 而 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）
    
- 引用计数算法
    
    策略 引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下 它的策略是跟踪记录每个变量值被使用的次数
    
    当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1 如果同一个值又被赋给另一个变量，那么引用数加 1 如果该变量的值被其他的值覆盖了，则引用次数减 1 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存 如下例
    
    let a = new Object() // 此对象的引用计数为 1（a引用） let b = a // 此对象的引用计数是 2（a,b引用） a = null // 此对象的引用计数为 1（b引用） b = null // 此对象的引用计数为 0（无引用） … // GC 回收此对象 复制代码 这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子
    
    function test(){ let A = new Object() let B = new Object()
    
    A.b = B B.a = A } 复制代码 如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放 我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一 在 IE8 以及更早版本的 IE 中，BOM 和 DOM 对象并非是原生 JavaScript 对象，它是由 C++ 实现的 组件对象模型对象（COM，Component Object Model），而 COM 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 COM 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 DOM 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系，如下
    
    // COM对象 let ele = document.getElementById(“xxx”) let obj = new Object()
    
    // 造成循环引用 obj.ele = ele ele.obj = obj
    
    // 切断引用关系 obj.ele = null ele.obj = null 复制代码 不过在 IE9 及以后的 BOM 与 DOM 对象都改成了 JavaScript 对象，也就避免了上面的问题 此处参考 JavaScript高级程序设计 第四版 4.3.2 小节 优点 引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾 而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了 缺点 引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的
    
- V8对GC的优化
    

### 正则表达式

### 内存泄露

### 事件机制

### 错误定位

### 面向对象

- 封装
    
    封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。
    
- 继承
    
    继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
    
- 多态
    
    多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
    

### 事件冒泡

### 事件循环

---

1. 0-9[↩︎](about:blank#fnref1)